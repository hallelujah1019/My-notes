# JS高级技术笔记(高级的JS很重要)

## 第一天(ES6中的类和对象)

### 1.编程的两大思想：

- 面向过程

	- 一般是用于小项目
	- 注重过程，多用于简单程序。

- 面向对象

	- 多人合作大项目，多用于复发程序。
	- 面向对象是把事务分解成为一个个对象，然后对象之间分工与合作。

### 2.面向对象的三大特性：

- 封装性
- 继承性
- 多态性

### 3.面向对象和面向过程的优缺点

- 面向过程：

	- 优点：性能比面向对象要高，步骤联系紧密，只要有一步出错，就会导致整个逻辑代码出错儿。
面向过程实现功能很直接，所以性能要比面向对象要高。
	- 缺点：不好维护，不易多次使用及扩展。

- 面向对象：

	- 优点：易维护(方法之间互不影响)，可复用，可扩展，灵活性高。
	- 缺点：性能没有面向过程高。

### 4.ES6中的类和对象

- 类：泛指一类，在JS的ES6中才出现类的概念。
- 对象：类中的具体的某个实例。是属性和方法的集合体，只要是对象，就有属性和方法。
- 对象是由属性和方法组成的：

	- 对象中“有”什么叫对象的属性，属性一般是用来访问的
对象“做”什么叫方法，方法一般是用来执行的
对象中只有这两个东西
	- 属性：事物的特征，在对象中用属性来表示（常用名词）语法：对象.属性名;
	- 方法：事物的行为，在对象中用方法来表示（常用动词）语法：对象.方法名();

### 5.类class(ES6中才有的类概念)

- 先有的类，再有的对象。
- 创建一个类：
class 类名 {
   花括号中需要放一些共有属性和共有的方法。
};
注意：类名首字母需要大写(其实也可以小写啦，这是一种书写规范)
类中需要放一些公共的属性和方法。
- 创建类的目的是为了实例化对象，类的作用就是实例化对象用的。
- 创建一个对象：语法：
var 变量名 = new 类名()；
这个变量名，就是一个类的实例对象;
- 对象 instanceof 构造函数 --->返回值是一个布尔值，true/false判断该对象属不属于一个数组(Array)或者一个对象(Object)
arr instanceof Array;--->Array表示数组类
意思是：判断arr是不是个数组
obj instanceof Object；--->判断obj这个对象属不属于Object，或者说判断obj这个变量是不是对象类型。

### 6.类constructor构造函数(ES6中)

- 类里面的公共方法不准带function
- 构造函数constructor的作用，是放一些对象中的公共的属性，并且只能是放属性，不能放方法，属性和方法不能混放
一 new必定执行构造函数constructor这个构造函数，但是普通的方法并不会调用，普通方法只有在调用的时候才能执行，只有构造函数在new()对象的时候就被执行。
- 语法：
class Star{
  constructor(uname){--->uname表示形参
     //属性，对象.属性
     //this：表示当前实例对象
     this.属性名 = 属性值;
     this.xingming = uname;
     构造函数中的this指向的是当前的实例对象，一定要记住构造函数中this的指向。
   }
}
var obj = new Star('张三丰');--->表示实参
var obj1 = new Star('成龙');
- 如果我们没有手动写这个构造函数constructor()，系统也会给我们自动添加一个空的构造函数，我们只要一 new，constructor这个构造函数就是肯定会存在的。

### 7.在类中添加方法

- 类中不许出现function这个关键字
- 每个方法之间不要使用任何标点符号，直接写  方法名(){}   即可
例如：
add(){}
remove(){}
.....
- class Star{
  //构造函数constructor
  constructor(uname,age){
    this.uname = uname;
    this.age = age;
  }
   //注意普通的方法不需要添加function这个关键字
   chang () {--->方法名或者叫函数名
     
   }
    //方法与方法之间不需要添加任何标点符号
   shuo () {
 
  }
}

### 8.ES6中类的继承

- class Father{}--->父类
class Son extends Father{--->子类继承父类

}
关键字：extends
- 如果子类中没有constructor构造函数，就可以直接继承父类的constructor构造函数
如果子类中也有构造函数constructor的时候，就要使用super关键字类调用父类中的构造函数和普通函数。
当子类和父类都有同样的构造函数和方法的时候，就要使用super关键字。
- 关键字：
super：作用调用父类中的构造函数和普通函数(方法)
- 如果父类和子类中方法名是一样的（冲突的），我们使用关键字super类调用父类中的方法。super.方法名();(这个方法名是父类中的方法);
- 如果，子类中不写任何东西，我们就可以直接继承父类中的方法和构造函数，没有问题；
但是，如果子类中有和父类相同的构造函数和方法，我们就要使用super关键字来调用父类中的构造函数和普通函数。
- 子类继承父类的语法：
class Son extends Father {
    // 如果子类中也有自己的构造函数和普通方法，子类中的构造函数中的形参需要将父类中的形参都要传进去，因为实例对象的时候，对象中的实参个数是需要一一对应的，不能漏传，因为子类是继承了父类，父类中的属性子类中就不需要再写一遍了，这里我们使用super关键字来将父类中的属性继承过来就可以啦。
    constructor(uname, age, sex, like) {
        // 使用super关键字来将父类中的属性继承过来
        super(uname, age);--->父类中有的属性
        this.sex = sex;--->这两个属性是子类私有的属性
        this.like = like;
      }
      // 如果子类中也有和父类相同的普通函数的时候
    tiao() {
      // 我们使用super关键字调用父类中的与子类名字一样的普通函数
      super.tiao();
      console.log('姑娘也会跳舞');
    }

### 9.三个注意点：

-  在ES6中必须要先定义类，再去实例化对象，顺序不要颠倒，ES6中没有变量的提升，先定义再实例。
- 类中调用属性和方法需要加this关键字，注意：这是在类中操作属性或方法的时候，需要加this关键字。一定要记住，在类中调用属性和方法的时候也是对象.属性//对象.方法名()；
- 类中的this指向的问题

	- 构造函数中的this一定是指向的是当前new出来的实例对象
	- 普通函数中的this指向的是谁调用普通方法this指向的就是谁，也就是说this指向的的是当前调用者。
	- 给元素绑事件的时候，方法是不需要带括号的
this.btn.onclick = this.cli;--->cli后面就不需要带括号，如果加上括号就是方法的调用的方式了，不加括号的意思是说：只有当用户点击的时候才会调用这个方法。

### 10.构造函数中只需要写属性，方法不要放到构造函数中，不要混放。

### 11.对象添加自定义属性的方法

- 添加自定义属性的第一种方法：
.setAttribute('index',6);--->这种方法是往标签上添加的，
.getAttribute('index');--->获取自定义属性
- 给对象添加属性的第二种方法：
对象.index = 6;--->这是往DOM树上添加自定义属性，这种方式不会在标签上显示自定义属性。

### 12.在父标签中添加子标签的一个新方法：
elemtent.insertAdjacentHTML('beforebegin',text);
参数1：位置，beforebegin元素自身的前面
afterbegin：插入元素内部的第一个子节点之后
beforeend：插入元素内部的第一个子节点之前
参数2：直接写字符串或者代表字符串的变量
var li = `<li>红颜一笑，江山美人<li>`
ul.insertAdjacentHTML('beforebegin',li);--->这句代码的意思就是将创建的这个li标签添加到了ul列表中了

## 第二天(ES5中对象对象的使用)

### 1.ES5中创建对象的方法：

- ES5中：
第一种创建对象的方法：字面量方法创建对象
var obj = {
  //成员
  name：'张三丰',
  age：22,
  sex：'男',
  taiji：function(){
  console.log('我会打太极');
  }
}
console.log(obj.name/obj.age/obj.sex/obj.taiji);--->这儿要注意，这里的taiji()这个方法也可以理解成是这个对象中的一个属性，加括号就是调用这个函数，不加小括号儿就是打印这个方法
- 第二种方法创建对象：利用构造函数创建对象，这个Object是系统给到我们的，相当于系统中已经写好了一个构造函数 function Object (){};
var obj = new Object();--->我们直接来new对象就好
给对象添加属性时是用对象名.属性名的方法
例如：这里的属性也叫成员
obj.uname = '李寻欢';
//给对象添加一个方法
obj.feidao = function(){
  alert('我会玩儿板儿');
}
给元素添加事件就是给元素添加方法，onclick(点击事件)、onblur(失去光标焦点事件)   onfocus(获取光标焦点)
- 第三种创建对象的方法：自定义构造函数创建对象，自定义构造函数的名字首字母要大写(帕斯卡命名法)，重要：构造函数要和new联合使用才有意义，构造函数如果不和new一块儿使用，那么这个函数就是一个普通函数。
function Star(){}--->自定义构造函数，自定义构造函数的作用就是用来实例化对象的
var obj = new Star();--->这里的obj就是一个对象
给对象添加属性的方法：对象名.属性名，但是我们一般不这样单独添加属性，我们要在function Star(){}这个构造函数中添加属性uname，age.....
//obj.name = '李寻欢';
语法：
function Star(uname,age){--->这里需要形参进行接收
  this.uame = uname;
  this.age = age;
}
var obj = new Star('张三丰'，12);--->需要进行传实参
- 第四种创建对象的方法：工厂模式创建对象，但是现在一般不用了，可以忽略啦；
function createPerson(name,age,job){
　　　　var o = new Object();
　　　　o.name = name;
　　　　o.age = age;
　　　　o.job = job;
　　　　o.sayName = function(){
　　　　　　alert(this.name);
　　　　}
　　　　return o;
　　}
　　var person1 = createPerson('Grey',27,'Doctor');
　　函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建\多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。　
　　主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。
　　工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。

### 2.new 关键字在执行的时候会做4件事儿（new的执行过程）

- 1.在堆中创建一个新空间(中创建一个空对象)
- 2.this指向这个空对象
- 3.执行函数中代码，将属性和方法给到这个空对象
- 4.返回这个新对象（所以构造函数中不需要return）
- 对象只要是碰到了new，肯定这个对象肯定是有一个自己独立的空间。

### 3.静态成员和实例成员

- 在构造函数身上(在构造函数外边添加的成员)的成员叫静态成员
静态成员只能由构造函数访问，反过来说构造函数只能访问静态成员儿
- 在构造函数里面的成员叫实例成员
实例成员只能是实例对象访问，实例对象只能访问实例成员

### 4.多次创建对象会浪费空间，所以构造函数中一般不放方法（因为方法是复杂数据类型），属性是简单数据类型，每次new的时候就会在堆中开辟一个空间存放方法，所以会浪费很多没必要的空间
练习：给数组的原型对象中添加三个方法，一个求数组元素和的方法，一个求数组中最大值的方法，一个求数组中最小值的方法。
Array.prototype.Max = function(){};

### 5.构造函数的原型对象：prototype

- 对象名.prototype;--->返回值是一个对象，我们叫这个属性叫原型对象，这个对象给构造函数当属性了，每一个构造函数都有一个原型对象(prototype)，这个原型对象的本质就是一个构造函数中的属性。
以后构造函数中只放公共的属性，只放属性；方法要放到原型对象prototype中
- 这个原型对象的作用是：为了共享方法，节省空间
- 语法：
function Star(uname,age){
  this.uname = uname;
  this.age = age;
  注意：方法不要放到构造函数中
}
//方法放到原型对象中放
Star.prototype.chang = function(){
  console.log('我会唱');
}
Star.prototype.tiao = function(){
  console.log('我会跳');
}
var obj = new Star('张三丰',22);
obj.chang();--->这里依然可以调用到方法，但是为什么可以实例对象可以直接用原型对象中的方法呢？因为是有对象原型(__proto__)的存在，注意这里说的是对象原型(而不是原型对象),__proto__就是用来指向prototype(原型对象)，所以可以直接使用原型对象中的方法。
- 添加多个方法的语法：这个方式添加的方法没有constructor这个属性了，但是为什么constructor没了呢，因为这个方式添加方法是把constructor覆盖掉了，但是为什么会被覆盖呢，因为Star.prototype本身是一个对象。
Star.prototype = {
  constructor : Star,
  chang: function(){},
  tiao: function(){},
  rap: function(){}
}

### 6.原型  __proto__--->(前后都是两个下划线)

- 每一个对象都有一个__proto__属性(这个属性是只读属性，使用来看的);
这个属性的作用就是：__proto__(对象原型)就是用来指向prototype(原型对象)；
- __proto__(原型)和prototype(原型对象)是等价的
- 统一 一下叫法：__proto__我们叫做原型
                       prototype我们叫做原型对象

### 7.constructor构造函数本身

- 对象.constructor；
这里的constructor的作用是指回构造函数本身，或者说constructor就是构造函数本身
如果我们忘记了当前这个对象是哪个构造函数new出来的，我们可以使用constructor来找回是哪个构造函数new出来的对象，也是原型对象的属性。
- 构造函数.constructor
- 构造函数.prototype.constructor
- constructor是原型对象上的一个属性，对象本身是没有constructor的，对象之所以可以直接使用constructor是因为对象上有原型__proto__，对象是通过__proto__指向的原型对象的，原型对象下面有一个属性是constructor，然后通过constructor找回原构造函数。

### 8.原型链

- 原型链的作用就是提供一个成员的查找机制(方向)，或者查找规则。
原型链最高只能是查找到Object，直到找到null就会报错儿。
- 什么是原型链，就是使用原型(__proto__)串起来的一个东西。
- 当前找的到的就用当前的方法，如果当前没有方法那就通过原型__proto__一直往上找，只要是这个原型链不断，就会一直找，直到找到null为止。

### 9.ES5中的继承(重点)

-  我们通过 构造函数+原型对象 模拟实现继承，我们称之为组合继承
- 改变this指向的方法

	- 使用call(this,参数1，参数2.....)方法

		- 语法：
函数.call(参数1);--->参数1表示的是this的指向,一般参数1就是写this。
function fn(){
   console.log(this);
}
var obj = {name:   '张三丰'}
fn.call(obj);--->括号中的参数是若干个，但是第一个参数一定是要写想要this指向的对象。

- 属性的继承

	- function Father(uname,age){
   this.uname = uname;
   this.age = age;
}
function Son(uname,age,score){
   Father.call(this,uname,age);--->使用call()方法改变父类中this的指向
   this.score = score;--->如果子类中有自己私有属性的话就在后面直接写就行。
}

- 方法的继承(重要)

	- function Father(){}
Father.prototype.say = function(){
   console.log('唱歌');
}
function Son(){}
Son.prototype = new Father();--->把父类的实例对象赋值给子类的原型对象
Son.prototype.constructor = Son;--->因为Son.prototype = new Father()这个方法是对象和对象之间的赋值，所以Son.prototype原型对象中的constructor被覆盖掉了，所以我们要再给Son.prototype指向一下函数本身。
	- 方法的继承：把父类的实例对象赋值给子类的原型对象就可以继承父类中的方法；
Son.prototype = new Father();
Son.prototype.constructor = Son;--->一定要让Son再指回构造函数

- 子类中的私有方法

	- 如果子类既想继承父类中的方法又想拥有自己的私有方法，那么程序在执行的时候就有一个先后顺序：需要子类先继承完毕后子类的方法，再让子类拥有自己的私有方法，也就是说在书写代码的时候我们要先让子类继承完毕后父类的方法，然后再书写子类中自己的私有方法
	- 具体代码：
//   刚才前面说到，ES5中的继承是组合继承，属性我们使用call()方法来继承，但是方法的继承我们就要使用对象给对象赋值的方法来继承父类中的方法，我们使用这个方法来继承：将父类的实例对象赋值给到子类的原型对象  Son.prototype = new Father();
  Son.prototype = new Father();
  //   因为Son.prototype = new Father();这个方法是对象给对象赋值，从而导致Son.prototype中的constructor这个属性进行了覆盖，所以我们还要将子类中的constructor再指向子类的构造函数
  Son.prototype.constructor = Son;
  //   子类中也会有私有的方法，同样，子类中的私有方法也是放到原型对象prototype中的，但是这要注意：子类中有私有属性的前提是子类已经继承完毕了父类中的方法，也就是说如果子类既想继承父类中的方法又想有自己的私有方法，那么就要先继承父类中的方法，再写子类中私有的方法
  Son.prototype.chang = function() {
      console.log(this.uname + '我还没有过时');
    }

- 自定义属性讲解：

	- 1.先获取DOM节点
	- 操作属性的话，如果操作的是固有属性，直接对象.属性就可以操作，例如：btn.id
	- 如果是自定义属性的话，不准使用对象.属性这种方法来访问自定义属性，这种方法是行不通的
	- 获取自定义属性的方法：
对象.getAttribute('自定义属性名');
这种方法就可以获取到DOM节点中的自定义属性值
	- 设置自定义属性的方法：
对象.setAttribute('自定义属性名',自定义属性值);
这个方法就可以给DOM节点添加了一个自定义属性。
	- img.自定义属性名 = '属性值'；这种方法是往DOM树上进行添加的属性，并不会在标签上体现出来，每一个标签节点就是一个对象，是对象，对象下面就有属性和方法。

## 第四天

### 1.函数的递归学习或者叫递归函数

- 函数自己调用自己这种模式就是递归；
函数调用其本身就是递归。
- 栈溢出现象：
递归函数的作用和循环效果一样，由于递归很容易发生栈溢出错误(stack overflow)，所以必须要加退出条件return。

### 2.深拷贝和浅拷贝

- 拷贝：--->简单数据类型是值进行传递
var n = 3;
var m;
m = n;
把n的值进行了传递
- 访问对象中的属性有两种方法：
第一种方法：对象.属性名
第二种方法：对象['属性名'];
- 复杂数据类型的拷贝，实质拷贝的是地址，这不是真正的拷贝
- 浅拷贝：浅拷贝只能拷贝外面的一层属性，不能拷贝对象中复杂数据类型。
遍历对象我们使用for(key in obj){
    key表示的是键，这个键名随便写但是我们一般写key，obj表示的是当前遍历的对象
    如果想要获取对象中的属性值；我们使用
   console.log(obj[key]);
}
在forin遍历数组的时候，不允许对象.属性名这种方法访问属性，我们要使用对象['属性名']这种方法进行访问对象的数字
- ES6中的新增的浅拷贝方法

	- 浅拷贝方法：
Object.assign(参数1，参数2);--->(newObj，obj)
参数1：需要拷贝值给到的对象空对象
参数2：要拷贝对象
	- ES6中的暂时还没有深拷贝的方法

- 深拷贝方法

	- 深拷贝需要用到的知识点就是使用的递归原理。

### 3.正则表达式

- 我们自己写一个规则，来判断用户输入的内容符不符合自己写的这个规则，这就是正则表达式的作用。
- 正则表达式的作用：正则表达式是用于匹配字符串中字符组合模式的
检索关键字，过滤敏感字符，表单验证(表单验证是重点)
- 正则表达式由：简单字符  和    特殊字符(元字符)    组成。
- 正则表达式特点：

	- 1.灵活性、逻辑性和功能性非常强。
	- 2.可以迅速的用极简单的方式达到字符串的复杂控制。
	- 3.对于刚接触的人来讲，比较隐晦难懂。
	- 4.正则表达式在开发中一般是去网上复制别人的正则表达式即可。

- JS中使用正则表达式的方法

	- 1.使用构造函数创建正则表达式
var reg = new RegExp(/abc/);--->解释：只要输入的内容中有abc即可
	- 2.字面量方式创建正则表达式
var reg = /123/;--->内容只要包括123即可

- 测试正则表达式

	- 使用test()方法来测试正则表达式，返回值是一个布尔值。
	- var reg = /abc/;--->只要包含abc就行，这的abc是一个整体，并不是说包含a或b或c
reg.test('asjdhjah');--->返回true
reg.test('abcdjfkd');--->返回true

- 特殊字符(元字符)

	- 边界符

		- ^: 表示匹配行首文本以什么字符开头
例如：
var reg = /^abc/;--->以abc开头
console.log(reg.test('abcdkfdk'));--->true
console.log(reg.test('adkfdjdkfdk'));--->false
		- $: 表示匹配行文本以什么字符结尾
var reg = /abc$/;--->以abc结尾
console.log(reg.test('dkfdkabc'));--->true
console.log(reg.test('adkfdjdkfdk'));--->false
		- 如果^和$在一起使用，那就是精确匹配
例如：
var reg = /^abc$/;--->内容只能是abc
console.log(reg.test('abc'));--->true
console.log(reg.test('aabbcc'));--->false
console.log(reg.test('123abc'));--->false

	- 方括号[]，被中括号包含的东西只能是选一个

		- 中括号[]是多选一的意思，只要是加了中括号儿，就不会出现1个以上的情况，多选一
		- var reg = /[abc]/;--->包含a/b/c其中的一个即可
console.log(reg.test('dkfjdkjfa'));--->true，因为有a所以为true
var reg = /^[abc]$/;--->只能是a或b或c
console.log(reg.test('aaa'));--->false
console.log(reg.test('ccc'));--->false
console.log(reg.test('a'));--->true
console.log(reg.test('b'));--->true
console.log(reg.test('c'));--->true
		- 组合
var reg = /^[a-z]&/;--->26个英文字母中的小写字母中多选一
		- var reg = /^[a-zA-Z]$/;--->小a到小z或大A到大Z中其中的一个
		- var reg = /^[a-zA-Z0-9]$/;小a到小z或大A到大Z0-9中其中的一个
		- var reg = /^[a-zA-Z0-9_-]$/;小a到小z或大A到大Z0-9以及下划线_和中划线-中其中的一个
		- var reg = /^[^a-zA-Z0-9_-]$/;--->只能是非他们之中的一个，中括号加了^就是取反的意思

	- 量词符

		- *号
var reg = /^[a-c]*$/--->重复0次或更多次
		- +号
var reg = /^[a-z]+$/;--->重复0次或1次
		- ？号
var reg = /^[a-z]?$/;--->重复0次或1次
		- {n}
var reg = /^[a-z]{3}$/;--->重复3次
		- {n,}/{n,m}--->最少n次，最多m次
var reg = /^[a-z]{3,}$/;--->最少出现3次
var reg = /^[a-z]{3,6}$/;--->最少出现3次，最多出现6次

### 4.预定义类

- \d--->[0-9]
var reg = /^[\d]$/;--->等同于/[^[0-9]$]/
- \D--->[^0-9]取反
- \w小写
表示0-9a-zA-Z
- \W大写
- \s小写   
匹配空格符
var reg = /^[  ]$/;--->true
- \S大写
匹配非空格符
- location.href获取地址栏  
location.search是获取http://localhost:4000/detail.html?id=461这个地址中的       这个?id=461字符串的方法
使用location对象可以获取浏览器地址栏上所有的信息
- location.href = 'http://www.baidu.com';--->跳转页面。
- 获取当前浏览器的信息。
alert(navigator.userAgent);

### 5.replace替换

- 字符串里面的方法
replace(参数1，参数2);--->返回值是一个新字符串,
参数1：替换谁
参数2：替换成什么
例如：
var str = 'adkdkfk'；
//替换
var newstr = str.replace('b','*******');
- /正则表达式/[修饰符]
g:表示全局匹配
i：忽略大小写
gi：全局忽略大小写
- var str = 'bdkfjkbdkfjkdBdkfjdk';
console.log(str.replace(/b/gi，'******'));
语法解释：
将字符换str中的内容为所有内容为b的不区分大小写，全部替换成******，g的作用是全局表示的是所有的字符串，i表示的是忽略大小写
- 敏感字过滤(屏蔽)

	- // 获取元素
        var btn = document.querySelector('input');
        var txt = document.querySelector('#d1');
        var ul = document.querySelector('ul');
       // 添加事件
       btn.onclick = function () {
       // 获取内容
       var val = txt.value;
       // 创建li
       var li = document.createElement('li');
       // 放到ul
       ul.appendChild(li);
       // 判断处理
       val = val.replace(/搞基|gay/gi, '**');
       // 放入内容
       li.innerHTML = val;
       // 清空
       txt.value = '';
      }

## 第三天

### 1.类的本质

- 类其实也是function构造函数写出来的
也是有__proto__原型的
- i = i + 1;--->它叫语法盐
i++;--->它叫语法糖，糖表示的是简写
i = i+1是i++的语法盐
i++是i = i + 1的语法糖
简单来记就是：简写叫糖，繁写叫盐
- ES6就是ES5的语法糖
ES5就是ES6的语法盐

### 2.ES5中新增的方法

- 1.数组的方法

	- 1.遍历(迭代)的方法：这几个方法都是用来遍历数组的

		- forEach()

			- 语法：遍历哪个数组，哪个数组直接调用forEach()即可
arr.forEach(function(item，index，arr){

});
参数1：遍历的当前项，也就是说数组中的元素
参数2：遍历的当前项的下标也就是当前项的索引值
参数3：表示遍历的当前数组本身，一般这个参数很少去写

		- filter()

			- 语法：遍历哪个数组，哪个数组直接调用filter()即可
arr.filter(function(item，index，arr){
       return item > 3;
       或者
       return item%2==0;--->返回所有的偶数
       或者
       return item%2!=0;--->返回所有的奇数
});
参数1：遍历的当前项(数组中每一项的内容)，也就是说数组中的元素
参数2：遍历的当前项的下标也就是当前项的索引值
参数3：表示遍历的当前数组本身，一般这个参数很少去写

注意：但是filter方法有一个筛选的功能，返回值是一个新的数组

		- some()

			- 语法：遍历哪个数组，哪个数组直接调用some()即可
arr.some(function(item，index，arr){
   return   item==100;--->查找数组中有没有元素是100，返回值是一个布尔值
});
参数1：遍历的当前项，也就是说数组中的元素
参数2：遍历的当前项的下标也就是当前项的索引值
参数3：表示遍历的当前数组本身，一般这个参数很少去写


注意：some()方法可以查找一个数组中有没有符合条件的某个元素
some()方法返回值是一个布尔值，true/false，如果找到了符合条件的元素，some()会自动停止程序，因为已经找的了，所以就不往后进行遍历了。
为什么找到后就停止程序了呢？因为return这个关键字，只有满足条件的的时候，程序就会停止，满足条件返回一个布尔值true，就是因为return true了，程序才会停止，
return false就不会停止。

		- map()

			- 语法：
arr.map(参数1，参数2);
解释：
参数1：回调函数，这个参数是必须写的，此函数会针对数组中的每一个元素执行一次。回调函数可以有三个参数item，index，arr，这三个参数的含义和forEach()中的形参含义是一样的。
参数2：这个参数可写可不写，这个参数的作用是规定回调函数中this所指向的对象，如果省略的话，this指向的的window对象。
			- 例如：
function Fn(banjing) {
    //   求一下圆的面积
    var a = Math.PI * (banjing * banjing);
    // toFixed();表示的是保留几位小数，0的意思是不保留小数位
    return a.toFixed(0);
  }
  // 定义一个数组
  var arr = [2, 3, 4, 5];
  // 使用map()进行遍历，调用Fn函数，数组中的每一项会当做banjing的实参进行传递，然后返回一个新数组，一般map中需要传递就是一个回调函数
  var arr1 = arr.map(Fn);
  console.log(arr1);

		- every()

			- every()方法是判断数组中的元素满不满足回调函数中的条件的，如果数组中的所有元素都满足回调函数中的条件，那么返回值就是一个true；如果数组中只要有一个元素不满足回调函数中的条件，那么就会返回一个false，从而终止程序，只要有一个与回调函数中条件不符合的元素，every()就会终止执行，并返回一个false。
			- 语法：
function Fn(a) {
    return a > -60;
  }
  var arr = [1, 3, 4, 543, 343];
  //   every()中也是需要传一个回调函数，用来判断数组中的元素是不是都大于-60，如果有一个不是大于-60的元素，回调函数就会返回一个false，如果数组中的所有元素都满足判断条件，就会返回一个true。
  var arr1 = arr.every(Fn);
  console.log(arr1);

		- 拓展：下拉列表：
option中value值就是select中的value中的值。
如果option中没有value值的时候，select的value值就会拿到option中的文本内容

- 2.字符串的方法

	- 1.trim()方法
去除字符串两端的空白位进行去除

		- 字符串的方法只能是字符串调用
		- var str = ' abcd ';--->如果直接打印的话，就会将两端的空白位打印出来
str.trim();--->使用这个方法就会将字符串两端的空白位进行删除，
但是trim()这个方法只能是清空字符串两端的空白位。

### 3.函数进阶
函数都是方法写出来的

- 1.函数的定义和调用

	- 函数定义的方法
每一个函数都是一个实例对象

		- 命名函数

			- function fn (){
   console.log(this);--->这里的this就是window
}
这个函数是window调用的。
调用的时候使用：方法名()的方式进行调用

		- 匿名函数

			- var fun = function （）{

};
			- 匿名函数的调用有两种方法，
第一种方法是将函数赋值给到一个变量，使用  变量()  的方法进行调用方法；
第二种方法是以自调用的方式进行调用，这里要注意，自调用函数是页面加载的时候函数就会被执行不需要调用。

		- 自调用函数(也是一种匿名函数)

			- 语法：
(function(形参){
   console.log(形参);
})(实参);
			- 例如：
(function(a,b){
    console.log(a,b);
  }
)(666,777);
语法解释：自调用函数，在页面进行加载的时候，就会执行。

		- 实例化对象定义函数(这种方法一般不用)

			- var obj = new Function('a','b','console.log("a+b")');--->前面的a和b就是形参
方法的调用：obj(1,2);
注意：这种方法定义的函数，function括号中的参数必须是字符串格式的。

	- 函数的调用

		- 1.普通函数的调用：
方法名();
		- 2.对象的方法/函数的调用：
对象.方法名();
		- 3.构造函数，以实例化对象的方法进行调用
new Fn();
		- 4.绑定事件函数
obj.onclick = function(){};
		- 5.定时器函数
window.setInterval(function(){},1000);
		- 6.立即执行函数--->匿名函数的一种
(function(形参){})(实参);

### 4.
始终记住一句话：
this指向当前调用者，这些this的指向，是我们调用函数的时候确定的，调用方法的不同决定了this的指向不同，但是一般指向的是我们的调用者。
只要是函数都可以放this，只要是有this，this的指向就可以被改变。

- 普通函数的this指向window
- 定时器函数中的this指向是window
- 立即执行函数(也就是自调用函数)中的this指向是window
- 构造函数的this指向当前的实例对象
- 对象方法调用中的this指向的是调用者
构造函数中的this指向的是实例对象，
普通方法中的this指向的是调用者
- 事件绑定方法中的this指向的是事件源/绑定事件对象(事件源)

### 5.改变函数内部this指向

- 改变this指向的方法
只要是函数，函数中就有this，只要有this就可以改变this的指向
改变this指向一定是函数调用这三个方法

	- 第一种方法
call();
应用场景：
经常用到继承上

		- call(参数1，参数2，...)；--->参数1表示的是想让this指向谁，就写谁
括号中第一个参数表示是想让this指向谁
例如：
function Fn(a,b){
  console.log(a,b);
}
var obj = {anme：‘李寻欢’};
Fn.call(obj,666,777);

	- 第二种方法：用的相对来说少一点
apply();
应用场景：
一般和数组有关系

		- 语法：
函数.apply(thisArg,[argsArray]);
参数1：想要this指向谁
参数2：只能放数组
		- 例如：
function fn(a,b){
   console.log(this,a,b);
}
var obj = {name:'李虚幻'};
fn.apply(obj,[888,999]);--->后面的实参以数组的形式进行传入
例如：
arr = [12,343,232,343434];
console.log(Math.max.apply(Math,arr));--->第二参数一定要是数组类型的

	- 第三种方法：这个方法用的最多
bind();
应用场景：
那么什么时候使用bind()这种方法呢？
当我们既想改变this指向又不想当前就调用函数的时候，我们就要使用bind()方法改变this指向。

		- 语法：bind()在改变this指向的时候，不会执行函数，只是改变了this的指向，这是bind()方法和call()、apply()方法的区别，返回一个改变this之后的函数。
var newFn = 函数.bind(thisArg,arg1,arg2....);
参数1：想要this指向的对象
参数2，参数3.。。。表示的是：形参
调用函数：
newFn();

### 6.严格模式

- JS分为两种模式：
正常模式--->之前我们写的JS都是正常模式
严格模式

	- 什么是严格模式？
var n = 3;--->正常行为，这种定义变量会预解析
n = 3;--->怪异行为，全局变量，这种方式不会预解析
	- 开启严格模式

		- "use strict";
只要在JS中写上这句话，就开启了js的严格模式
低版本的浏览器会将这句话解析成普通的字符串
开启了严格模式，代码的安全性更高了，速度更快了
		- 给整个脚本开启严格模式：只会给当前脚本开启严格模式
<script type = "text/javascript">
   //JS的脚本的第一句话就要写上"use strict"
   "use strict";--->给脚本中所有的代码开启了严格模式

</script>
		- 为一个函数内部开启严格模式：这种方法只是给当前函数开启了严格模式，函数开启了严格模式不会影响函数外部的脚本，严格模式只是在当前函数中起作用。
function fn(){
   //函数中的第一行代码就要写上"use strict";这句代码
  "use strict";
   
}

- 开启严格模式后的变化

	- 1.变量的规定
声明变量的时候必须要加var关键字
严格模式是不准删除已经声明的变量
例如：var a = 3;--->严格模式下，声明一个变量必须要var关键字
delete window.n;--->这种方法在严格模式下是要报错儿的，在严格模式下就不准删除一个已经声明的变量。
但是如果在正常模式下delete window.n;就可以删除一个已经声明的变量。
	- 2.严格模式下函数中的this指向
在普通模式下，普通函数的this的指向是window；
但是在严格模式下，普通函数的this的指向是undefined；--->记住就行
构造函数在严格模式下，只能是用new使用。
	- 3.函数的变化
在严格模式下，函数中的形参不能有重名；
例如：
function fn(a,a){};--->这种书写就是错误的，形参的名字不能重名，如果在严格模式下出现这种书写形式，就会报错儿。
函数的定义必须是在全局作用域下。

### 7.高阶函数
主要作用是啥呢？
现阶段还不好定义哈哈

- 高阶函数就是将函数可以当做值传来传去的这种就是高阶函数，也就是函数的回调。



函数也是一种值，我们把函数看做一种是特殊的值。
什么是高阶函数：
把函数当做参数传递或者把函数当做返回值返回的函数，叫做高阶函数。
被传递的参数叫做回调函数。
- 例如：
function fn(n){--->这里的形参接收的是一个函数，解释：把函数当做实参进行传递
   console.log(n);
   n();
}
var m = function(){console.log('娃哈哈')};
fn(m);--->把函数当做实参进行了传递。
这里的fn这个函数就是高阶函数，m这个函数我们叫做回调函数。
如果一个函数只有return，没有返回值的话，默认返回值就是undefined。
如果一个函数没有return，没有返回值的话，默认返回值是undefined。
- n&&n();
等同于
if(n){
 n();
}

### 8.闭包

- 闭包就是指有权访问另一个函数作用于中变量的函数。
简单理解就是：一个作用域可以访问另一个函数内部的局部变量，这种现象叫做闭包。
闭包现象是产生的最根本的原因是因为有作用域链的原因，当前作用域找不到的变量，作用域链会往上边的作用域找，这就是作用域链。
- 当函数执行完毕后，在函数中声明的变量，就会自动销毁。
- 闭包的作用：
延伸局部变量的作用范围或时长。
- 局部变量的销毁，闭包用到哪个局部变量就保留哪个局部变量
用不到的局部变量就会自动销毁，用得到的局部变量就会被保留下来。
- 闭包是针对函数中的局部变量来说的，只是针对局部变量来讲的。
- 闭包的格式：
一个函数包着一个函数，外层函数中的局部变量是对内层函数可见的，也就是说，如果里层函数想要访问外层函数中的局部变量的时候是可以被访问到的。但是外层函数想要访问里层函数中的局部变量是访问不到的，只能是向外(向上)访问，不能向里(向下)访问。
function fn(){
   var n = 3;
  // function nn(){
     //console.log(n);
   //}
   //nn();
   //把函数当做返回值进行返回
   return function(){
    console.log(n);
   }
}
fn();
现在这个fn = function(){
  console.log(n);
}
fn后面有一个括号，意思就是调用这个函数，因为有闭包现象的存在，所以可以访问到fn()函数中的局部变量n=3，由于有了闭包现象的存在，可以将函数中的局部变量提升到全局变量，因为如果是一个普通函数的话，当函数执行完毕后局部变量就会销毁掉，但是因为有闭包现象，这个局部变量就会保留下来。
- 所有的函数都是function的实例对象
所有的数组都是Array的实例对象
function fn(){};
其实相当于var fn = new Function();

*XMind: ZEN - Trial Version*